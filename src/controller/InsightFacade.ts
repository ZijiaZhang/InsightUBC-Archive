import Log from "../Util";
import {IInsightFacade, InsightDataset, InsightDatasetKind, InsightError, NotFoundError} from "./IInsightFacade";
import * as JSZip from "jszip";
import {DataSetDataCourse} from "../DataSetDataCourse";
import {JsonParser} from "../JsonParser";
import {QueryParser} from "../QueryParser";
import {DataSet} from "../DataSet";
import {Query} from "../Query";

/**
 * This is the main programmatic entry point for the project.
 * Method documentation is in IInsightFacade
 *
 */
export default class InsightFacade implements IInsightFacade {
    private dataSetMap: { [name: string]: DataSet } = {};
    private currentActiveDataset: string|null = null;
    constructor() {
        Log.trace("InsightFacadeImpl::init()");
    }

    public addDataset(id: string, content: string, kind: InsightDatasetKind): Promise<string[]> {
        return new Promise<string[]>((resolve, reject) => {
            if (!(InsightFacade.isIdValid(id)) || id in this.dataSetMap) {
                return reject(new InsightError("the given Parameter is not valid"));
            }
            // Create Database with name
            switch (kind) {
                case InsightDatasetKind.Courses:
                    this.dataSetMap[id] = new DataSetDataCourse(id);
                    break;
                case InsightDatasetKind.Rooms:
                    return reject(new InsightError("Room not Implemented yet"));
                default:
                    return reject(new InsightError("No such Type"));
            }
            return JSZip.loadAsync(content, {base64: true}).then(
                (zipFile: JSZip) => {
                    if (!("courses/" in zipFile.files)) {return reject(new InsightError("No Courses found in Zip")); }
                    let allPromise: Array<Promise<string>> = [];
                    zipFile.forEach((relativePath, file) => {
                        let names = relativePath.split("/");
                        if (names[0] !== "courses") {return; }
                        if (!file.dir) {
                            allPromise.push(file.async("text"));
                        }
                    });
                    if (allPromise.length <= 0) {return reject(new InsightError("No file Found in 'courses/'")); }
                    return this.handleAllFiles(allPromise, id, resolve, reject);
                }
            ).catch((reason: any) => {
                delete this.dataSetMap[id];
                return reject(new InsightError(reason));
            });
        });
    }

    /**
     *
     * @param allPromise           The promises generated by all the files.
     * @param id                   The ID of the dataset
     * @param resolve              The resolve function
     * @param reject               The reject function
     * This function will handel all the promises generged by all the files. And will resolve/ reject accordingly:
     * Will resolve if at least one valid solution has been added to the dataset.
     * Will reject if no valid section added to the dataset or an error occured.
     */

    private handleAllFiles(allPromise: Array<Promise<string>>, id: string,
                           resolve: (x: string[]) => any, reject: (x: InsightError) => any) {
        let validSectionCount = 0;
        return Promise.all(allPromise).then((datas) => {
            for (let data of datas) {
                let dataInFile = JsonParser.parseData(data, InsightDatasetKind.Courses);
                if (dataInFile != null) {
                    for (let dataRow of dataInFile) {
                        if (!this.dataSetMap[id].addData(dataRow)) {
                            return reject(new InsightError("Dataset not Loaded"));
                        }
                        validSectionCount++;
                    }
                }
            }
            if (validSectionCount <= 0) {
                return reject(new InsightError("No Section Valid"));
            }
            return this.dataSetMap[id].unloadDataSet()
                .then((fileloc) => resolve(Object.keys(this.dataSetMap)))
                .catch((err) => {
                    Log.error(err);
                    reject(new InsightError("Error Saving the File"));
                });
        }).catch((reason) => {
            return reject(new InsightError("Error Processing File"));
        });
    }

    public removeDataset(id: string): Promise<string> {
        return new Promise<string>((resolve, reject) => {
            if (!InsightFacade.isIdValid(id)) {
                return reject(new InsightError("Invalid ID"));
            }
            if (!(id in this.dataSetMap)) {
                return reject(new NotFoundError("Id Not found"));
            }

            delete this.dataSetMap[id];
            return resolve(id);
        });
    }

    public performQuery(query: any): Promise<any[]> {
        return new Promise<any[]>((resolve, reject) => {
            if (query === null || query === undefined) {
                reject(new InsightError("Query is null or undefined"));
            } else if (Query.checkEBNF(query)) {
                if (Query.checkSemantic(query)) {
                    QueryParser.getQueryResult(query).then((result) => {
                        resolve(result);
                    }).catch((err) => {
                        reject(err);
                    });
                } else {
                    reject(new InsightError("Query has semantic error"));
                }
            } else {
                reject(new InsightError("Query Syntax Not Valid"));
            }
        });
    }

    public listDatasets(): Promise<InsightDataset[]> {
        return new Promise<InsightDataset[]>((resolve, reject) => {
                let result: InsightDataset[] = [];
                for (let data of Object.values(this.dataSetMap)) {
                    result.push(data.getMetaData());
                }
                resolve(result);
            }
        );
    }

    /**
     *
     * @param id  The id of the dataset being added. Follows the format /^[^_]+$/
     *
     * @return boolean
     * Return if the given Dataset id is valid.
     */
    private static isIdValid(id: string): boolean {
        return !(id == null || id.includes("_") || id ===  "" || id.match(/^\s*$/g)) ;
    }

    /**
     *
     * @param name the name of the dataKind
     * Get the kind of data from the name
     * @return InsightDatasetKind the Kind of the data.
     * If there is no this kind of data reuturn null instead.
     */
    private static getDataKind(name: string): InsightDatasetKind {
        switch (name) {
            case "courses":
                return InsightDatasetKind.Courses;
            default:
                return null;
        }
    }

    /**
     * Switch the active dataset
     * @param name The name of the target dataset.
     * @return Promise<string>
     *     resolve on successful switch.
     *     Reject otherwise.
     */
    public switchDataSet(name: string): Promise<string> {
        return new Promise<string>( (resolve, reject) => {
            if (this.currentActiveDataset === name) {resolve("Dataset Already Loaded"); }
            if (!(name in this.dataSetMap)) {reject("Dataset Not Found"); }
            if (this.currentActiveDataset != null) {
                this.dataSetMap[this.currentActiveDataset].unloadDataSet().then(
                    (result) => {
                        return this.activeDataSet(name).then(
                            (result2) =>  resolve("Dataset Switched Successfully.")
                        ).catch( (err) => reject( new InsightError(err)));
                    }).catch( (err) => reject(new InsightError(err)));
            } else {
                return this.activeDataSet(name).then(
                    (result2) =>  resolve("Dataset Switched Successfully.")
                ).catch( (err) => reject( new InsightError(err)));
            }
    });
    }

    /**
     * Active a dataset and set it to current.
     * @param name The name of the target dataset.
     * @return Promise<string>
     *     resolve if activated Successfully.
     *     Reject otherwise.
     */

    private activeDataSet(name: string): Promise<string> {
        return new Promise<string>( (resolve, reject) => {
            if (this.currentActiveDataset === name) {resolve("Dataset Already Loaded"); }
            if (!(name in this.dataSetMap)) {reject("Dataset Not Found"); }
            this.dataSetMap[name].loadDataSet().then((result) => {
                this.currentActiveDataset = name;
                return resolve("Dataset Loaded"); })
                .catch((err) => {
                    this.currentActiveDataset = null;
                    return reject( new InsightError("Error When Loading Dataset")); } );
        });
    }
}
